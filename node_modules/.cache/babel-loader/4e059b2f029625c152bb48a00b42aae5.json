{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.$$ = exports.$ = undefined;\n\nvar _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\n\nexports.isReal = isReal;\nexports.isEl = isEl;\nexports.getEl = getEl;\nexports.createEl = createEl;\nexports.textContent = textContent;\nexports.insertElFirst = insertElFirst;\nexports.getElData = getElData;\nexports.hasElData = hasElData;\nexports.removeElData = removeElData;\nexports.hasElClass = hasElClass;\nexports.addElClass = addElClass;\nexports.removeElClass = removeElClass;\nexports.toggleElClass = toggleElClass;\nexports.setElAttributes = setElAttributes;\nexports.getElAttributes = getElAttributes;\nexports.getAttribute = getAttribute;\nexports.setAttribute = setAttribute;\nexports.removeAttribute = removeAttribute;\nexports.blockTextSelection = blockTextSelection;\nexports.unblockTextSelection = unblockTextSelection;\nexports.findElPosition = findElPosition;\nexports.getPointerPosition = getPointerPosition;\nexports.isTextNode = isTextNode;\nexports.emptyEl = emptyEl;\nexports.normalizeContent = normalizeContent;\nexports.appendContent = appendContent;\nexports.insertContent = insertContent;\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _guid = require('./guid.js');\n\nvar Guid = _interopRequireWildcard(_guid);\n\nvar _log = require('./log.js');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _tsml = require('tsml');\n\nvar _tsml2 = _interopRequireDefault(_tsml);\n\nvar _obj = require('./obj');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n}\n/**\n * @file dom.js\n * @module dom\n */\n\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\n\n\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\n\n\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\n\n\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\n\n\nfunction isReal() {\n  return (// Both document and window will never be undefined thanks to `global`.\n    _document2['default'] === _window2['default'].document && // In IE < 9, DOM methods return \"object\" as their type, so all we can\n    // confidently check is that it exists.\n    typeof _document2['default'].createElement !== 'undefined'\n  );\n}\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\n\n\nfunction isEl(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 1;\n}\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\n\n\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return _document2['default'][method](null);\n    }\n\n    if (isNonBlankString(context)) {\n      context = _document2['default'].querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : _document2['default'];\n    return ctx[method] && ctx[method](selector);\n  };\n}\n/**\n * Shorthand for document.getElementById()\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\n *\n * @param {string} id\n *         The id of the element to get\n *\n * @return {Element|null}\n *         Element with supplied ID or null if there wasn't one.\n */\n\n\nfunction getEl(id) {\n  if (id.indexOf('#') === 0) {\n    id = id.slice(1);\n  }\n\n  return _document2['default'].getElementById(id);\n}\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\n\n\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n\n  var el = _document2['default'].createElement(tagName);\n\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName]; // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      _log2['default'].warn((0, _tsml2['default'])(_templateObject, propName, val));\n\n      el.setAttribute(propName, val); // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\n\n\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n\n  return el;\n}\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n *\n */\n\n\nfunction insertElFirst(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n/**\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\n * Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\n\n\nvar elData = {};\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {string}\n * @constant\n * @private\n */\n\nvar elIdAttr = 'vdata' + new Date().getTime();\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\n\nfunction getElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    id = el[elIdAttr] = Guid.newGUID();\n  }\n\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n\n  return elData[id];\n}\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\n\n\nfunction hasElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\n\n\nfunction removeElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  } // Remove all stored data\n\n\n  delete elData[id]; // Remove the elIdAttr property from the DOM node\n\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\n\n\nfunction hasElClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n\n  return classRegExp(classToCheck).test(element.className);\n}\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\n\n\nfunction addElClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd); // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasElClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\n\n\nfunction removeElClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\n\n\nfunction toggleElClass(element, classToToggle, predicate) {\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasElClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  } // If the necessary class operation matches the current state of the\n  // element, no action is required.\n\n\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addElClass(element, classToToggle);\n  } else {\n    removeElClass(element, classToToggle);\n  }\n\n  return element;\n}\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\n\n\nfunction setElAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\n\n\nfunction getElAttributes(tag) {\n  var obj = {}; // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value; // check for known booleans\n      // the matching element property will return a value for typeof\n\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\n\n\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\n\n\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\n\n\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n/**\n * Attempt to block the ability to select text while dragging controls\n */\n\n\nfunction blockTextSelection() {\n  _document2['default'].body.focus();\n\n  _document2['default'].onselectstart = function () {\n    return false;\n  };\n}\n/**\n * Turn off text selection blocking\n */\n\n\nfunction unblockTextSelection() {\n  _document2['default'].onselectstart = function () {\n    return true;\n  };\n}\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} Dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {Dom~Position}\n *         The position of the element that was passed in.\n */\n\n\nfunction findElPosition(el) {\n  var box = void 0;\n\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var docEl = _document2['default'].documentElement;\n  var body = _document2['default'].body;\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = _window2['default'].pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = _window2['default'].pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop; // Android sometimes returns slightly off decimal values, so need to round\n\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\n\n\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findElPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n  return position;\n}\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\n\n\nfunction isTextNode(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 3;\n}\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\n\n\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n\n  return el;\n}\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\n\n\nfunction normalizeContent(content) {\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  } // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n\n\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return _document2['default'].createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\n\n\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\n\n\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\n\n\nvar $ = exports.$ = createQuerier('querySelector');\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\n\nvar $$ = exports.$$ = createQuerier('querySelectorAll');","map":{"version":3,"sources":["C:/test_website/ninjasatnoon/node_modules/video.js/es5/utils/dom.js"],"names":["exports","__esModule","$$","$","undefined","_templateObject","_taggedTemplateLiteralLoose","isReal","isEl","getEl","createEl","textContent","insertElFirst","getElData","hasElData","removeElData","hasElClass","addElClass","removeElClass","toggleElClass","setElAttributes","getElAttributes","getAttribute","setAttribute","removeAttribute","blockTextSelection","unblockTextSelection","findElPosition","getPointerPosition","isTextNode","emptyEl","normalizeContent","appendContent","insertContent","_document","require","_document2","_interopRequireDefault","_window","_window2","_guid","Guid","_interopRequireWildcard","_log","_log2","_tsml","_tsml2","_obj","obj","newObj","key","Object","prototype","hasOwnProperty","call","strings","raw","isNonBlankString","str","test","throwIfWhitespace","Error","classRegExp","className","RegExp","document","createElement","value","isObject","nodeType","createQuerier","method","selector","context","querySelector","ctx","id","indexOf","slice","getElementById","tagName","arguments","length","properties","attributes","content","el","getOwnPropertyNames","forEach","propName","val","warn","attrName","text","innerText","child","parent","firstChild","insertBefore","appendChild","elData","elIdAttr","Date","getTime","newGUID","e","element","classToCheck","classList","contains","classToAdd","add","trim","classToRemove","remove","split","filter","c","join","classToToggle","predicate","has","attrValue","tag","knownBooleans","attrs","i","name","attrVal","attribute","body","focus","onselectstart","box","getBoundingClientRect","parentNode","left","top","docEl","documentElement","clientLeft","scrollLeft","pageXOffset","clientTop","scrollTop","pageYOffset","Math","round","event","position","boxW","offsetWidth","boxH","offsetHeight","boxY","boxX","pageY","pageX","changedTouches","y","max","min","x","removeChild","Array","isArray","map","createTextNode","node"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.$$ = exports.$ = undefined;\n\nvar _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\n\nexports.isReal = isReal;\nexports.isEl = isEl;\nexports.getEl = getEl;\nexports.createEl = createEl;\nexports.textContent = textContent;\nexports.insertElFirst = insertElFirst;\nexports.getElData = getElData;\nexports.hasElData = hasElData;\nexports.removeElData = removeElData;\nexports.hasElClass = hasElClass;\nexports.addElClass = addElClass;\nexports.removeElClass = removeElClass;\nexports.toggleElClass = toggleElClass;\nexports.setElAttributes = setElAttributes;\nexports.getElAttributes = getElAttributes;\nexports.getAttribute = getAttribute;\nexports.setAttribute = setAttribute;\nexports.removeAttribute = removeAttribute;\nexports.blockTextSelection = blockTextSelection;\nexports.unblockTextSelection = unblockTextSelection;\nexports.findElPosition = findElPosition;\nexports.getPointerPosition = getPointerPosition;\nexports.isTextNode = isTextNode;\nexports.emptyEl = emptyEl;\nexports.normalizeContent = normalizeContent;\nexports.appendContent = appendContent;\nexports.insertContent = insertContent;\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _guid = require('./guid.js');\n\nvar Guid = _interopRequireWildcard(_guid);\n\nvar _log = require('./log.js');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _tsml = require('tsml');\n\nvar _tsml2 = _interopRequireDefault(_tsml);\n\nvar _obj = require('./obj');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; } /**\n                                                                                           * @file dom.js\n                                                                                           * @module dom\n                                                                                           */\n\n\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\nfunction isReal() {\n  return (\n\n    // Both document and window will never be undefined thanks to `global`.\n    _document2['default'] === _window2['default'].document &&\n\n    // In IE < 9, DOM methods return \"object\" as their type, so all we can\n    // confidently check is that it exists.\n    typeof _document2['default'].createElement !== 'undefined'\n  );\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\nfunction isEl(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 1;\n}\n\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return _document2['default'][method](null);\n    }\n    if (isNonBlankString(context)) {\n      context = _document2['default'].querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : _document2['default'];\n\n    return ctx[method] && ctx[method](selector);\n  };\n}\n\n/**\n * Shorthand for document.getElementById()\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\n *\n * @param {string} id\n *         The id of the element to get\n *\n * @return {Element|null}\n *         Element with supplied ID or null if there wasn't one.\n */\nfunction getEl(id) {\n  if (id.indexOf('#') === 0) {\n    id = id.slice(1);\n  }\n\n  return _document2['default'].getElementById(id);\n}\n\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n\n  var el = _document2['default'].createElement(tagName);\n\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName];\n\n    // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      _log2['default'].warn((0, _tsml2['default'])(_templateObject, propName, val));\n      el.setAttribute(propName, val);\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n  return el;\n}\n\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n *\n */\nfunction insertElFirst(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\n * Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\nvar elData = {};\n\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {string}\n * @constant\n * @private\n */\nvar elIdAttr = 'vdata' + new Date().getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\nfunction getElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    id = el[elIdAttr] = Guid.newGUID();\n  }\n\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n\n  return elData[id];\n}\n\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\nfunction hasElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\nfunction removeElData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\nfunction hasElClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n  return classRegExp(classToCheck).test(element.className);\n}\n\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\nfunction addElClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasElClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\nfunction removeElClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\nfunction toggleElClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasElClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addElClass(element, classToToggle);\n  } else {\n    removeElClass(element, classToToggle);\n  }\n\n  return element;\n}\n\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\nfunction setElAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\nfunction getElAttributes(tag) {\n  var obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n\n/**\n * Attempt to block the ability to select text while dragging controls\n */\nfunction blockTextSelection() {\n  _document2['default'].body.focus();\n  _document2['default'].onselectstart = function () {\n    return false;\n  };\n}\n\n/**\n * Turn off text selection blocking\n */\nfunction unblockTextSelection() {\n  _document2['default'].onselectstart = function () {\n    return true;\n  };\n}\n\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} Dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {Dom~Position}\n *         The position of the element that was passed in.\n */\nfunction findElPosition(el) {\n  var box = void 0;\n\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var docEl = _document2['default'].documentElement;\n  var body = _document2['default'].body;\n\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = _window2['default'].pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = _window2['default'].pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop;\n\n  // Android sometimes returns slightly off decimal values, so need to round\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findElPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n\n  return position;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\nfunction isTextNode(value) {\n  return (0, _obj.isObject)(value) && value.nodeType === 3;\n}\n\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n  return el;\n}\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\nfunction normalizeContent(content) {\n\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  }\n\n  // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return _document2['default'].createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\nvar $ = exports.$ = createQuerier('querySelector');\n\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\nvar $$ = exports.$$ = createQuerier('querySelectorAll');\n"]},"metadata":{},"sourceType":"script"}