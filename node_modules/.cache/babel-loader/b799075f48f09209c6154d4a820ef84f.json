{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.fixEvent = fixEvent;\nexports.on = on;\nexports.off = off;\nexports.trigger = trigger;\nexports.one = one;\n\nvar _dom = require('./dom.js');\n\nvar Dom = _interopRequireWildcard(_dom);\n\nvar _guid = require('./guid.js');\n\nvar Guid = _interopRequireWildcard(_guid);\n\nvar _log = require('./log.js');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\n\n\nfunction _cleanUpEvents(elem, type) {\n  var data = Dom.getElData(elem); // Remove the events of a particular type if there are none left\n\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type]; // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n    // Remove the meta-handler from the element\n\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  } // Remove the events object if there are no types left\n\n\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  } // Finally remove the element data if there is no data left\n\n\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    Dom.removeElData(elem);\n  }\n}\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\n\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\n\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\n\n\nfunction fixEvent(event) {\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n\n\n  if (!event || !event.isPropagationStopped) {\n    var old = event || _window2['default'].event;\n    event = {}; // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    } // The event occurred on this element\n\n\n    if (!event.target) {\n      event.target = event.srcElement || _document2['default'];\n    } // Handle which other element the event is related to\n\n\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    } // Stop the default browser action\n\n\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false; // Stop the event from bubbling\n\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse; // Stop the event from bubbling and executing other handlers\n\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse; // Handle mouse position\n\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = _document2['default'].documentElement;\n      var body = _document2['default'].body;\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    } // Handle key presses\n\n\n    event.which = event.charCode || event.keyCode; // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n\n    if (event.button !== null && event.button !== undefined) {\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  } // Returns fixed-up instance\n\n\n  return event;\n}\n/**\n * Whether passive event listeners are supported\n */\n\n\nvar _supportsPassive = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n\n    _window2['default'].addEventListener('test', null, opts);\n  } catch (e) {// disregard\n  }\n})();\n/**\n * Touch events Chrome expects to be passive\n */\n\n\nvar passiveEvents = ['touchstart', 'touchmove'];\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\n\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  var data = Dom.getElData(elem); // We need a place to store all our handler data\n\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = Guid.newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              _log2['default'].error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = {\n          passive: true\n        };\n      }\n\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\n\n\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!Dom.hasElData(elem)) {\n    return;\n  }\n\n  var data = Dom.getElData(elem); // If no events exist, nothing to unbind\n\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  } // Utility function\n\n\n  var removeType = function removeType(t) {\n    data.handlers[t] = [];\n\n    _cleanUpEvents(elem, t);\n  }; // Are we removing all bound events?\n\n\n  if (!type) {\n    for (var t in data.handlers) {\n      removeType(t);\n    }\n\n    return;\n  }\n\n  var handlers = data.handlers[type]; // If no handlers exist, nothing to unbind\n\n  if (!handlers) {\n    return;\n  } // If no listener was provided, remove all listeners for type\n\n\n  if (!fn) {\n    removeType(type);\n    return;\n  } // We're only removing a single handler\n\n\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\n\n\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument; // type = event.type || event,\n  // handler;\n  // If an event name was passed as a string, creates an event out of it\n\n  if (typeof event === 'string') {\n    event = {\n      type: event,\n      target: elem\n    };\n  } // Normalizes the event properties.\n\n\n  event = fixEvent(event); // If the passed element has a dispatcher, executes the established handlers.\n\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  } // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n\n\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash); // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = Dom.getElData(event.target); // Checks if the target has a default action for this event.\n\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true; // Executes the default action.\n\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      } // Re-enables event dispatching.\n\n\n      targetData.disabled = false;\n    }\n  } // Inform the triggerer if the default was prevented by returning false\n\n\n  return !event.defaultPrevented;\n}\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\n\n\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  }; // copy the guid to the new function so it can removed using the original function's ID\n\n\n  func.guid = fn.guid = fn.guid || Guid.newGUID();\n  on(elem, type, func);\n}","map":{"version":3,"sources":["C:/test_website/ninjasatnoon/node_modules/video.js/es5/utils/events.js"],"names":["exports","__esModule","fixEvent","on","off","trigger","one","_dom","require","Dom","_interopRequireWildcard","_guid","Guid","_log","_log2","_interopRequireDefault","_window","_window2","_document","_document2","obj","newObj","key","Object","prototype","hasOwnProperty","call","_cleanUpEvents","elem","type","data","getElData","handlers","length","removeEventListener","dispatcher","detachEvent","getOwnPropertyNames","disabled","removeElData","_handleMultipleEvents","fn","types","callback","forEach","event","returnTrue","returnFalse","isPropagationStopped","old","preventDefault","target","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","isImmediatePropagationStopped","clientX","undefined","doc","documentElement","body","pageX","scrollLeft","clientLeft","pageY","clientY","scrollTop","clientTop","which","charCode","keyCode","button","_supportsPassive","opts","defineProperty","get","addEventListener","e","passiveEvents","Array","isArray","guid","newGUID","push","hash","handlersCopy","slice","m","n","error","options","indexOf","passive","attachEvent","hasElData","removeType","t","splice","elemData","parent","parentNode","ownerDocument","bubbles","targetData","func","apply","arguments"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.fixEvent = fixEvent;\nexports.on = on;\nexports.off = off;\nexports.trigger = trigger;\nexports.one = one;\n\nvar _dom = require('./dom.js');\n\nvar Dom = _interopRequireWildcard(_dom);\n\nvar _guid = require('./guid.js');\n\nvar Guid = _interopRequireWildcard(_guid);\n\nvar _log = require('./log.js');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _window = require('global/window');\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _document = require('global/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\nfunction _cleanUpEvents(elem, type) {\n  var data = Dom.getElData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  }\n\n  // Finally remove the element data if there is no data left\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    Dom.removeElData(elem);\n  }\n}\n\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\nfunction fixEvent(event) {\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || _window2['default'].event;\n\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || _document2['default'];\n    }\n\n    // Handle which other element the event is related to\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    }\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = _document2['default'].documentElement;\n      var body = _document2['default'].body;\n\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button !== null && event.button !== undefined) {\n\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n}\n\n/**\n * Whether passive event listeners are supported\n */\nvar _supportsPassive = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n\n    _window2['default'].addEventListener('test', null, opts);\n  } catch (e) {\n    // disregard\n  }\n})();\n\n/**\n * Touch events Chrome expects to be passive\n */\nvar passiveEvents = ['touchstart', 'touchmove'];\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  var data = Dom.getElData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = Guid.newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              _log2['default'].error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = { passive: true };\n      }\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!Dom.hasElData(elem)) {\n    return;\n  }\n\n  var data = Dom.getElData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  }\n\n  // Utility function\n  var removeType = function removeType(t) {\n    data.handlers[t] = [];\n    _cleanUpEvents(elem, t);\n  };\n\n  // Are we removing all bound events?\n  if (!type) {\n    for (var t in data.handlers) {\n      removeType(t);\n    }\n    return;\n  }\n\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) {\n    return;\n  }\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n  // type = event.type || event,\n  // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = { type: event, target: elem };\n  }\n  // Normalizes the event properties.\n  event = fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash);\n\n    // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = Dom.getElData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.defaultPrevented;\n}\n\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n\n  // copy the guid to the new function so it can removed using the original function's ID\n  func.guid = fn.guid = fn.guid || Guid.newGUID();\n  on(elem, type, func);\n}\n"]},"metadata":{},"sourceType":"script"}