{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.each = each;\nexports.reduce = reduce;\nexports.assign = assign;\nexports.isObject = isObject;\nexports.isPlain = isPlain;\n/**\n * @file obj.js\n * @module obj\n */\n\n/**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n */\n\n/**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */\n\nvar toString = Object.prototype.toString;\n/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */\n\nvar keys = function keys(object) {\n  return isObject(object) ? Object.keys(object) : [];\n};\n/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */\n\n\nfunction each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}\n/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */\n\n\nfunction reduce(object, fn) {\n  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return keys(object).reduce(function (accum, key) {\n    return fn(accum, object[key], key);\n  }, initial);\n}\n/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */\n\n\nfunction assign(target) {\n  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (Object.assign) {\n    return Object.assign.apply(Object, [target].concat(sources));\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      target[key] = value;\n    });\n  });\n  return target;\n}\n/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\n\n\nfunction isObject(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\n\n\nfunction isPlain(value) {\n  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;\n}","map":{"version":3,"sources":["C:/test_website/ninjasatnoon/node_modules/video.js/es5/utils/obj.js"],"names":["exports","__esModule","_typeof","Symbol","iterator","obj","constructor","prototype","each","reduce","assign","isObject","isPlain","toString","Object","keys","object","fn","forEach","key","initial","arguments","length","undefined","accum","target","_len","sources","Array","_key","apply","concat","source","value","call"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.each = each;\nexports.reduce = reduce;\nexports.assign = assign;\nexports.isObject = isObject;\nexports.isPlain = isPlain;\n/**\n * @file obj.js\n * @module obj\n */\n\n/**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n */\n\n/**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */\nvar toString = Object.prototype.toString;\n\n/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */\nvar keys = function keys(object) {\n  return isObject(object) ? Object.keys(object) : [];\n};\n\n/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */\nfunction each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}\n\n/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */\nfunction reduce(object, fn) {\n  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  return keys(object).reduce(function (accum, key) {\n    return fn(accum, object[key], key);\n  }, initial);\n}\n\n/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */\nfunction assign(target) {\n  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (Object.assign) {\n    return Object.assign.apply(Object, [target].concat(sources));\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isObject(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\n/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isPlain(value) {\n  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;\n}\n"]},"metadata":{},"sourceType":"script"}